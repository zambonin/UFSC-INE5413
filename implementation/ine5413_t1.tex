\documentclass{../sftex/sftex}

\title{Implementação de um grafo}
\author{Gustavo Zambonin}
\email{gustavo.zambonin@grad.ufsc.br}
\src{https://github.com/zambonin/ufsc-ine5413}
\uniclass{Grafos}
\classcode{UFSC-INE5413}

\begin{document}

\maketitle

A estrutura utilizada para a implementação de um grafo assemelha-se a um mapa.
Utiliza como chave um vértice e como valor um conjunto de outros vértices aos
quais este se conecta. Na linguagem escolhida, Python, estas estruturas são
chamadas de \texttt{dict} e \texttt{set}. A fonte utilizada para verificar a
complexidade de recursos da linguagem pode ser acessada
\href{https://wiki.python.org/moin/TimeComplexity}{aqui}.

\begin{itemize}
    \item \texttt{add\_vertex} \\
    Um mapa adiciona chaves em tempo constante. $\mathbf{O(1)}$

    \item \texttt{remove\_vertex} \\
    A remoção de um vértice sem conexões acontece em $O(1)$. Caso existam arestas
    conectadas a ele, então é necessário iterar sobre todos os vértices
    existentes e verificar se o vértice está presente no conjunto de conexões.
    A iteração leva tempo linear, e a operação de presença tem caso médio $O(1)$.
    $\mathbf{O(n)}$

    \item \texttt{connect\_two\_vertices} \\
    Mapear valores para chaves leva tempo constante. $\mathbf{O(1)}$

    \item \texttt{disconnect\_two\_vertices} \\
    Remover valores de chaves leva tempo constante. $\mathbf{O(1)}$

    \item \texttt{graph\_order} \\
    A operação de tamanho de lista leva tempo constante. $\mathbf{O(1)}$

    \item \texttt{get\_vertices} \\
    A iteração sobre as chaves de um mapa leva tempo linear. $\mathbf{O(n)}$

    \item \texttt{get\_random\_vertex} \\
    A complexidade temporal para gerar um número aleatório no módulo
    \texttt{random} em Python consegue ser
    \href{https://docs.python.org/2/library/random.html}{constante}. O método
    chamado na implementação presente, \texttt{choice}, pode ser consultado
    \href{https://hg.python.org/cpython/file/2.7/Lib/random.py#l273}{aqui}.
    $\mathbf{O(1)}$

    \item \texttt{get\_vertex\_predecessors} \\
    Checar se um vértice está presente em $n$ conjuntos leva tempo linear.
    $\mathbf{O(n)}$

    \item \texttt{get\_vertex\_sucessors} \\
    Acessar o valor de uma chave leva tempo constante. $\mathbf{O(1)}$

    \item \texttt{get\_adjacent\_vertices} \\
    Caso o grafo seja direcionado, unir dois conjuntos leva tempo linear. Do
    contrário, acessar o valor de uma chave leva tempo constante. $\mathbf{O(n)}$
    ou $\mathbf{O(1)}$

    \item \texttt{get\_vertex\_indegree} \\
    Tamanho do retorno de \texttt{get\_vertex\_precedessors}. $\mathbf{O(n)}$

    \item \texttt{get\_vertex\_outdegree} \\
    Tamanho do retorno de \texttt{get\_vertex\_sucessors}. $\mathbf{O(1)}$

    \item \texttt{get\_vertex\_degree} \\
    Tamanho do retorno de \texttt{get\_adjacent\_vertices}. $\mathbf{O(n)}$ ou
    $\mathbf{O(1)}$

    \item \texttt{graph\_regularity} \\
    Pode ser necessário iterar sobre todos os vértices. $\mathbf{O(n)}$

    \item \texttt{graph\_completeness} \\
    Novamente, pode-se mostrar necessário iterar sobre a lista inteira de
    vértices. $\mathbf{O(n)}$

    \item \texttt{transitive\_closure} \\
    O número de testes será proporcional ao somatório dos graus de saída
    de cada vértice, ou seja, o número de arestas do grafo. $\mathbf{O(m)}$

    \item \texttt{graph\_connectivity} \\
    Utiliza o retorno de \texttt{transitive\_closure}. $\mathbf{O(m)}$

    \item \texttt{is\_tree} \\
    O método interno \texttt{check\_cycles} calcula os vértices adjacentes de
    todos os vértices do grafo, e o retorno chama \texttt{graph\_connectivity}.
    $\mathbf{O(n^2)}$
\end{itemize}

\end{document}
